・アムダールの法則
並列化による高速化は、高速化したい問題（処理）のうち、どの程度が並列化可能であるかに大きく依存する

・平行・並列化のパターン一覧
同期処理を非同期にする
非同期にしたものを同期化する
タスク生成と処理を分ける（Producer-Consumerパターン）
開始した順で処理する（チャネルのチャネル）
タスク処理が詰まったら待機（バックプレッシャー）
並列なForループ
決まった数のgoroutineでタスクを消化する（ワーカープール）
依存関係のあるタスクを表現する（Future/Promise）
イベントの流れを定義する（ReactiveX）
自立した複数のシステムで協調動作（アクターモデル）

・同期処理を非同期にする
→例えば、複数のファイルの読み込みを同期的に行うのではなく、goroutineとして切り出す。
```go
inputs := make(chan []byte)
 
go func() {
    a, _ := ioutil.ReadFile("a.txt")
    inputs<-a
}()
 
go func() {
    b, _ := ioutil.ReadFile("b.txt")
    inputs<-b
}()
```

・非同期にしたものを同期化する
非同期化した処理はどこかで同期をとる必要がある。
一つのgoプログラムから複数のチャネルを読み込む場合、select文が必要。
16を参照。
sync.WaitGroupで複数のタスクの完了待ち
sync.Condでスタート待ち
sync.Mutexでクリティカルセクションの処理が交錯するのを避ける
こともできる。

・タスク生成と処理を分ける（Producer-Consumerパターン）
golangなら、同一プロセス内ならchannelでproducerとcomsumerを接続するだけでよい
チャネルでは、複数のgoroutineで読み込みを行っても、必ず一つのgoroutineだけが結果を受け取ることができる。
プロセスをまたぐ場合はメッセージキューのミドルウェアが必要

・開始した順で処理する（チャネルのチャネル）
チャネルだけだと、早く終了したものから処理することになる。終了を待ってから処理を開始することになる。
早く開始したものから処理したい場合は、チャネルのチャネルを利用する。

・タスク処理が詰まったら待機（バックプレッシャー）
詰まりそうになったら送信側の送信量を落とすように受信側から通知することをバックパブリッシャーという
goroutineの場合、バッファ付きチャネルを作成すればよい。
```go
tasks := make(chan string, 10)
```

・並列forループ
forループ内をgoroutineにすれば並列化できる。
ループ変数の実態は一つのみのため、goroutineの引数として渡し、各goroutineでコピーが作成されるようにする。
ループ内の処理が小さい場合はオーバーヘッドの方が大きくなることがある。


・決まった数のgoroutineでタスクを消化する（ワーカープール）
workerPool.goを参照